# debug_core/debugger.py
# [AI]
# Generated by assistant under integrator review
# @tags:
#   domain: UI
#   data_affinity: actor_data
#   scope_horizon: mvp
#   semantic_role: runtime_behavior

import os
import json
import datetime

# Optional DEBUG_MODE global for quick no-op
try:
    from config import DEBUG_MODE
except ImportError:
    DEBUG_MODE = True


class Debugger:
    """Structured logger that enforces debug rules and writes to .jsonl.

    Each instance is scoped to a specific context (e.g., "combat/resolve").
    It builds, validates, and optionally prints each debug entry.
    """

    def __init__(self, context: str):
        """Initializes a debugger for a given context string.
        Loads rules and opens output file for appending.
        """
        self.context = self._sanitize_context(context)
        self.rules = self._load_rules()
        self.output_path = os.path.join("debug_logs", f"{self.context}.jsonl")

        os.makedirs("debug_logs", exist_ok=True)

    def __call__(self, action, data=None, state=None, ai_tags=None, trace_id=None, print_console=False):
        """Submits a debug entry for logging and optional console output.

        Required:
        - action: str (e.g., "resolve_attack")

        Optional:
        - data: any structured object
        - state: any structured object
        - ai_tags: list of strings
        - trace_id: UUID string to correlate logs across flow
        - print_console: bool
        """
        if not DEBUG_MODE:
            return None

        entry = {
            "timestamp": datetime.datetime.utcnow().isoformat(),
            "context": self.context,
            "action": action,
        }

        if data is not None:
            entry["data"] = data
        if state is not None:
            entry["state"] = state
        if ai_tags is not None:
            entry["ai_tags"] = ai_tags
        if trace_id is not None:
            entry["trace_id"] = trace_id

        self._validate_entry(entry)

        with open(self.output_path, "a", encoding="utf-8") as f:
            f.write(json.dumps(entry) + "\n")

        if print_console:
            print(f"[{self.context}] {action} | tags: {ai_tags} | trace_id: {trace_id}")

        return entry

    def _validate_entry(self, entry: dict):
        """Enforces required fields and rule structure for debug entries."""
        required = ["timestamp", "context", "action"]
        for field in required:
            if field not in entry:
                raise ValueError(f"[DEBUG] Missing required field: {field}")

        # Validate ISO8601 timestamp
        try:
            datetime.datetime.fromisoformat(entry["timestamp"])
        except ValueError:
            raise ValueError(f"[DEBUG] Invalid timestamp format: {entry['timestamp']}")

        # Action format check
        if self.rules.get("enforce_action_format", False):
            if not isinstance(entry["action"], str) or "_" not in entry["action"]:
                raise ValueError(f"[DEBUG] Action must be in 'verb_noun' format: got '{entry['action']}'")

        # ai_tags validation
        if self.rules.get("require_ai_tags", False):
            tags = entry.get("ai_tags")
            if not isinstance(tags, list) or not all(isinstance(t, str) for t in tags) or not tags:
                raise ValueError(f"[DEBUG] ai_tags must be a non-empty list of strings")

        # state/data presence validation
        if self.rules.get("require_state_or_data", False):
            if "data" not in entry and "state" not in entry:
                raise ValueError("[DEBUG] Must include at least one of 'data' or 'state'")

        # Optional structure checks
        if "state" in entry and not isinstance(entry["state"], dict):
            raise ValueError("[DEBUG] 'state' must be a dictionary if present")

        if "data" in entry and not isinstance(entry["data"], dict):
            raise ValueError("[DEBUG] 'data' must be a dictionary if present")

    def _load_rules(self) -> dict:
        """Loads debug_rules.json if available, otherwise returns default lenient rules."""
        rules_path = os.path.join("debug_core", "debug_rules.json")
        try:
            with open(rules_path, "r", encoding="utf-8") as f:
                return json.load(f)
        except FileNotFoundError:
            return {
                "enforce_action_format": False,
                "require_ai_tags": False,
                "require_state_or_data": False,
                "output_format": "jsonl",
                "file_naming_policy": "context_sanitized.jsonl"
            }
        except json.JSONDecodeError as e:
            raise RuntimeError(f"[DEBUG] Invalid debug_rules.json: {e}")

    def _sanitize_context(self, context: str) -> str:
        """Makes context filename-safe by replacing unsafe characters with underscores."""
        return context.replace("/", "_").replace("\\", "_").replace(":", "_")
